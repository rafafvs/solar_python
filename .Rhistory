# Unconstraint parameters
phi <-  GARCH_params_to_zeta(zeta, archOrder, garchOrder)
# GARCH filter
omega <- phi[1]
alpha <- phi[1 + seq_len(archOrder)]
beta  <- phi[archOrder + 1 + seq_len(garchOrder)]
# GARCH std. deviation
sigma <- sqrt(sGARCH_filter(y, omega, alpha, beta))
# Standardized residuals
z_hat <- y / sigma
# Log-likelihood
if (per_obs){
log(dnorm(z_hat) / sigma)
} else{
sum(log(dnorm(z_hat) / sigma))
}
}
# Optimal parameters
opt <- optim(zeta, function(params) -sGARCH_loss_loglik(params, y, archOrder, garchOrder, per_obs = FALSE))
# Total order
pq <- archOrder + garchOrder
zeta <- runif(pq)
# Loss function
loglik <- function(zeta, per_obs = FALSE){
zeta <- c(zeta, 0)
# Unconstraint parameters
phi <-  GARCH_from_zeta_to_phi_any(zeta, archOrder, garchOrder)
# GARCH filter
omega <- phi[1]
alpha <- phi[1 + seq_len(archOrder)]
beta  <- phi[archOrder + 1 + seq_len(garchOrder)]
# GARCH std. deviation
sigma <- sqrt(sGARCH_filter(x, omega, alpha, beta))
# Standardized residuals
z_hat <- x / sigma
# Log-likelihood
if (per_obs){
log(dnorm(z_hat) / sigma)
} else{
sum(log(dnorm(z_hat) / sigma))
}
}
# Optimal parameters
opt <- optim(zeta, function(params) -sGARCH_loss_loglik(params, y, archOrder, garchOrder, per_obs = FALSE))
zeta
params <- zeta
per_obs = FALSE
zeta <- c(zeta, 0)
# Unconstraint parameters
phi <-  GARCH_params_to_zeta(zeta, archOrder, garchOrder)
zeta
# Unconstraint parameters
phi <-  GARCH_params_to_zeta(zeta[-3], archOrder, garchOrder)
archOrder
garchOrder
# Unconstraint parameters
phi <-  GARCH_params_to_zeta(zeta, archOrder, garchOrder)
# Unconstraint parameters
phi <-  GARCH_params_to_phi(zeta, archOrder, garchOrder)
sGARCH_loss_loglik <- function(zeta, y, archOrder, garchOrder, per_obs = FALSE){
zeta <- c(zeta, 0)
# Unconstraint parameters
phi <-  GARCH_params_to_phi(zeta, archOrder, garchOrder)
# GARCH filter
omega <- phi[1]
alpha <- phi[1 + seq_len(archOrder)]
beta  <- phi[archOrder + 1 + seq_len(garchOrder)]
# GARCH std. deviation
sigma <- sqrt(sGARCH_filter(y, omega, alpha, beta))
# Standardized residuals
z_hat <- y / sigma
# Log-likelihood
if (per_obs){
log(dnorm(z_hat) / sigma)
} else{
sum(log(dnorm(z_hat) / sigma))
}
}
# Total order
pq <- archOrder + garchOrder
zeta <- runif(pq)
# Optimal parameters
opt <- optim(zeta, function(params) -sGARCH_loss_loglik(params, y, archOrder, garchOrder, per_obs = FALSE))
opt
# QMLE params
theta_star_qmle <- c(opt$par, 0)
# QMLE params (constraint)
theta_qmle <- GARCH_params_to_phi(theta_star_qmle, archOrder, garchOrder)
theta_qmle
jacobian_reduced(opt$par, archOrder, garchOrder)
J <- jacobian_reduced(opt$par, archOrder, garchOrder)
# Numerical Hessian matrix at QMLE
H <- numDeriv::hessian(func = function(params) -sGARCH_loss_loglik(params, y, archOrder, garchOrder, per_obs = FALSE), x = theta_star_qmle, per_obs = FALSE)
# Numerical Hessian matrix at QMLE
H <- numDeriv::hessian(func = function(params) -sGARCH_loss_loglik(params, y, archOrder, garchOrder, per_obs = FALSE), x = theta_star_qmle)
# Numerical Score at QMLE
S <- numDeriv::jacobian(func = function(params) -sGARCH_loss_loglik(params, y, archOrder, garchOrder, per_obs = TRUE), x = theta_star_qmle)
# Cross products of the score
B <- matrix(0, pq, pq)
for(i in 1:nrow(S)) {
B <- B + S[i,] %*% t(S[i,])
}
+1
# Cross products of the score
B <- matrix(0, pq+1, pq+1)
for(i in 1:nrow(S)) {
B <- B + S[i,] %*% t(S[i,])
}
# Var-cov matrix (unbounded)
V_star <- solve(-H)
std.errors_zeta <- sqrt(diag(V_star))
names(std.errors_zeta) <- names(theta_star_qmle)
std.errors_zeta
V_star
solve(-H)
# Numerical Hessian matrix at QMLE
H <- numDeriv::hessian(func = function(params) sGARCH_loss_loglik(params, y, archOrder, garchOrder, per_obs = FALSE), x = theta_star_qmle)
# Numerical Score at QMLE
S <- numDeriv::jacobian(func = function(params) sGARCH_loss_loglik(params, y, archOrder, garchOrder, per_obs = TRUE), x = theta_star_qmle)
H
pq
# Cross products of the score
B <- matrix(0, pq+1, pq+1)
for(i in 1:nrow(S)) {
B <- B + S[i,] %*% t(S[i,])
}
# Var-cov matrix (unbounded)
V_star <- solve(-H)
std.errors_zeta <- sqrt(diag(V_star))
names(std.errors_zeta) <- names(theta_star_qmle)
# Var-cov matrix (constraint)
V_orig <- J %*% V_star %*% t(J)
std.errors_phi <- sqrt(diag(V_orig))
V_star
J
theta_star_qmle
theta_star_qmle <- opt$par
# Numerical Hessian matrix at QMLE
H <- numDeriv::hessian(func = function(params) sGARCH_loss_loglik(params, y, archOrder, garchOrder, per_obs = FALSE), x = theta_star_qmle)
# Numerical Score at QMLE
S <- numDeriv::jacobian(func = function(params) sGARCH_loss_loglik(params, y, archOrder, garchOrder, per_obs = TRUE), x = theta_star_qmle)
# Cross products of the score
B <- matrix(0, pq+1, pq+1)
# Cross products of the score
B <- matrix(0, pq, pq)
for(i in 1:nrow(S)) {
B <- B + S[i,] %*% t(S[i,])
}
# Var-cov matrix (unbounded)
V_star <- solve(-H)
std.errors_zeta <- sqrt(diag(V_star))
names(std.errors_zeta) <- names(theta_star_qmle)
# Var-cov matrix (constraint)
V_orig <- J %*% V_star %*% t(J)
std.errors_phi <- sqrt(diag(V_orig))
names(std.errors_phi) <- names(theta_qmle)
# Sandwitch var-cov matrix (unbounded)
V_rob_star <- V_star %*% B %*% V_star
std.errors_rob_zeta <- sqrt(diag(V_rob_star))
names(std.errors_rob_zeta) <- names(theta_star_qmle)
# Sandwitch var-cov matrix (constraint)
V_rob_orig <- J %*% V_rob_star %*% t(J)
std.errors_rob_phi <- sqrt(diag(V_rob_orig))
names(std.errors_rob_phi) <- names(theta_qmle)
std.errors_rob_phi
std.errors_rob_zeta
std.errors_zeta
std.errors_phi
spec <- rugarch::ugarchspec(variance.model = list(garchOrder = c(1, 1), variance.targeting = 1),
mean.model = list(armaOrder = c(0, 0), include.mean = FALSE))
# Safe GARCH fit
coef <- rugarch::ugarchfit(spec, x)@fit$coef
coef
sum(rugarch::ugarchfit(spec, x)@fit$log.likelihood)
opt$value
theta_star_qmle
theta_qmle
theta_star_qmle
sGARCH_fit <- function(x, archOrder = 1, garchOrder = 1, mode = c("unitOmega","targetSigma2","freeOmega")){
# Total order
pq <- archOrder + garchOrder
zeta <- runif(pq)
# Optimal parameters
opt <- optim(zeta, function(params) -sGARCH_loss_loglik(params, y, archOrder, garchOrder, per_obs = FALSE))
# QMLE params (unconstraint)
theta_star_qmle <- opt$par
# QMLE params (constraint)
theta_qmle <- GARCH_params_to_phi(c(theta_star_qmle, 0), archOrder, garchOrder)
# Jacobian
J <- jacobian_reduced(theta_star_qmle, archOrder, garchOrder)
# Numerical Hessian matrix at QMLE
H <- numDeriv::hessian(func = function(params) sGARCH_loss_loglik(params, y, archOrder, garchOrder, per_obs = FALSE), x = theta_star_qmle)
# Numerical Score at QMLE
S <- numDeriv::jacobian(func = function(params) sGARCH_loss_loglik(params, y, archOrder, garchOrder, per_obs = TRUE), x = theta_star_qmle)
# Cross products of the score
B <- matrix(0, pq, pq)
for(i in 1:nrow(S)) {
B <- B + S[i,] %*% t(S[i,])
}
# Var-cov matrix (unbounded)
V_star <- solve(-H)
std.errors_zeta <- sqrt(diag(V_star))
names(std.errors_zeta) <- names(theta_star_qmle)
# Var-cov matrix (constraint)
V_orig <- J %*% V_star %*% t(J)
std.errors_phi <- sqrt(diag(V_orig))
names(std.errors_phi) <- names(theta_qmle)
# Sandwitch var-cov matrix (unbounded)
V_rob_star <- V_star %*% B %*% V_star
std.errors_rob_zeta <- sqrt(diag(V_rob_star))
names(std.errors_rob_zeta) <- names(theta_star_qmle)
# Sandwitch var-cov matrix (constraint)
V_rob_orig <- J %*% V_rob_star %*% t(J)
std.errors_rob_phi <- sqrt(diag(V_rob_orig))
names(std.errors_rob_phi) <- names(theta_qmle)
theta_qmle
theta_star_qmle
std.errors_zeta
std.errors_phi
std.errors_rob_zeta
std.errors_rob_phi
}
sGARCH_fit(x, 1, 1)
sGARCH_fit(x, 1, 2)
spec <- rugarch::ugarchspec(variance.model = list(garchOrder = c(1, 2), variance.targeting = 1),
mean.model = list(armaOrder = c(0, 0), include.mean = FALSE))
# Safe GARCH fit
coef <- rugarch::ugarchfit(spec, x)@fit$coef
coef
sGARCH_fit(x, 1, 2)
sGARCH_fit(x, 2, 1)
sGARCH_fit <- function(x, archOrder = 1, garchOrder = 1, mode = c("unitOmega","targetSigma2","freeOmega")){
# Total order
pq <- archOrder + garchOrder
zeta <- runif(pq)
# Optimal parameters
opt <- optim(zeta, function(params) -sGARCH_loss_loglik(params, y, archOrder, garchOrder, per_obs = FALSE))
# QMLE params (unconstraint)
theta_star_qmle <- opt$par
# QMLE params (constraint)
theta_qmle <- GARCH_params_to_phi(c(theta_star_qmle, 0), archOrder, garchOrder)
# Jacobian
J <- jacobian_reduced(theta_star_qmle, archOrder, garchOrder)
# Numerical Hessian matrix at QMLE
H <- numDeriv::hessian(func = function(params) sGARCH_loss_loglik(params, y, archOrder, garchOrder, per_obs = FALSE), x = theta_star_qmle)
# Numerical Score at QMLE
S <- numDeriv::jacobian(func = function(params) sGARCH_loss_loglik(params, y, archOrder, garchOrder, per_obs = TRUE), x = theta_star_qmle)
# Cross products of the score
B <- matrix(0, pq, pq)
for(i in 1:nrow(S)) {
B <- B + S[i,] %*% t(S[i,])
}
# Var-cov matrix (unbounded)
V_star <- solve(-H)
std.errors_zeta <- sqrt(diag(V_star))
names(std.errors_zeta) <- names(theta_star_qmle)
# Var-cov matrix (constraint)
V_orig <- J %*% V_star %*% t(J)
std.errors_phi <- sqrt(diag(V_orig))
names(std.errors_phi) <- names(theta_qmle)
# Sandwitch var-cov matrix (unbounded)
V_rob_star <- V_star %*% B %*% V_star
std.errors_rob_zeta <- sqrt(diag(V_rob_star))
names(std.errors_rob_zeta) <- names(theta_star_qmle)
# Sandwitch var-cov matrix (constraint)
V_rob_orig <- J %*% V_rob_star %*% t(J)
std.errors_rob_phi <- sqrt(diag(V_rob_orig))
names(std.errors_rob_phi) <- names(theta_qmle)
theta_qmle
theta_star_qmle
std.errors_zeta
std.errors_phi
std.errors_rob_zeta
std.errors_rob_phi
theta_qmle
}
sGARCH_fit(x, 2, 1)
format(sGARCH_fit(x, 2, 1), digits = 4, scientific = FALSE)
format(sGARCH_fit(x, 2, 1), digits = 4, scientific = FALSE)
spec <- rugarch::ugarchspec(variance.model = list(garchOrder = c(2, 1), variance.targeting = 1),
mean.model = list(armaOrder = c(0, 0), include.mean = FALSE))
# Safe GARCH fit
coef <- rugarch::ugarchfit(spec, x)@fit$coef
coef
format(coef, digits = 4, scientific = FALSE)
format(sGARCH_fit(x, 1, 2), digits = 4, scientific = FALSE)
spec <- rugarch::ugarchspec(variance.model = list(garchOrder = c(1, 2), variance.targeting = 1),
mean.model = list(armaOrder = c(0, 0), include.mean = FALSE))
# Safe GARCH fit
coef <- rugarch::ugarchfit(spec, x)@fit$coef
format(coef, digits = 4, scientific = FALSE)
sum(rugarch::ugarchfit(spec, x)@fit$log.likelihood)
#' # Simple GARCH(1,1)
#' set.seed(1)
#' x <- rnorm(1000)
#' omega <- 0.1; alpha <- 0.05; beta <- 0.9
#' s2 <- sGARCH_filter_c(x, omega, alpha, beta)  # no initials
#'
#' # With initials (k=max(p,q)=1)
#' s2_i <- sGARCH_filter_c(x, omega, alpha, beta, eps0 = 0, sigma20 = 0.2)
#'
#' @export
sGARCH_filter_c(x, omega, alpha, beta, eps0 = NULL, sigma20 = NULL)
#' # Simple GARCH(1,1)
#' set.seed(1)
#' x <- rnorm(1000)
#' omega <- 0.1; alpha <- 0.05; beta <- 0.9
#' s2 <- sGARCH_filter_c(x, omega, alpha, beta)  # no initials
#'
#' # With initials (k=max(p,q)=1)
#' s2_i <- sGARCH_filter_c(x, omega, alpha, beta, eps0 = 0, sigma20 = 0.2)
#'
#' @export
sGARCH_filter_c <- function(x, omega, alpha, beta, eps0 = NULL, sigma20 = NULL) {
if (is.null(eps0) != is.null(sigma20))
stop("Either provide both eps0 and sigma20, or neither.")
.Call("sGARCH_filter_c",
as.numeric(x),
as.numeric(omega),
as.numeric(alpha),
as.numeric(beta),
if (is.null(eps0)) NULL else as.numeric(eps0),
if (is.null(sigma20)) NULL else as.numeric(sigma20))
}
#' # Simple GARCH(1,1)
#' set.seed(1)
#' x <- rnorm(1000)
#' omega <- 0.1; alpha <- 0.05; beta <- 0.9
#' s2 <- sGARCH_filter_c(x, omega, alpha, beta)  # no initials
#'
#' # With initials (k=max(p,q)=1)
#' s2_i <- sGARCH_filter_c(x, omega, alpha, beta, eps0 = 0, sigma20 = 0.2)
#'
#' @export
sGARCH_filter_c(x, omega, alpha, beta, eps0 = NULL, sigma20 = NULL)
sGARCH_filter(x, omega, alpha, beta, eps0 = NULL, sigma20 = NULL)
sGARCH_filter_c(x, omega, alpha, beta, eps0 = NULL, sigma20 = NULL)-
sGARCH_filter(x, omega, alpha, beta, eps0 = NULL, sigma20 = NULL)
system.time(map(1:100, ~sGARCH_filter_c(x, omega, alpha, beta, eps0 = NULL, sigma20 = NULL)))
system.time(purrr::map(1:100, ~sGARCH_filter_c(x, omega, alpha, beta, eps0 = NULL, sigma20 = NULL)))
system.time(purrr::map(1:100, ~sGARCH_filter(x, omega, alpha, beta, eps0 = NULL, sigma20 = NULL)))
source("~/Desktop/solarr/R/sGARCH-internals.R", echo = TRUE)
sGARCH_loss_loglik <- function(zeta, y, archOrder, garchOrder, per_obs = FALSE){
zeta <- c(zeta, 0)
# Unconstraint parameters
phi <-  GARCH_params_to_phi(zeta, archOrder, garchOrder)
# GARCH filter
omega <- phi[1]
alpha <- phi[1 + seq_len(archOrder)]
beta  <- phi[archOrder + 1 + seq_len(garchOrder)]
# GARCH std. deviation
sigma <- sqrt(sGARCH_filter_c(y, omega, alpha, beta))
# Standardized residuals
z_hat <- y / sigma
# Log-likelihood
if (per_obs){
log(dnorm(z_hat) / sigma)
} else{
sum(log(dnorm(z_hat) / sigma))
}
}
sGARCH_fit <- function(x, archOrder = 1, garchOrder = 1, mode = c("unitOmega","targetSigma2","freeOmega")){
# Total order
pq <- archOrder + garchOrder
zeta <- runif(pq)
# Optimal parameters
opt <- optim(zeta, function(params) -sGARCH_loss_loglik(params, y, archOrder, garchOrder, per_obs = FALSE))
# QMLE params (unconstraint)
theta_star_qmle <- opt$par
# QMLE params (constraint)
theta_qmle <- GARCH_params_to_phi(c(theta_star_qmle, 0), archOrder, garchOrder)
# Jacobian
J <- jacobian_reduced(theta_star_qmle, archOrder, garchOrder)
# Numerical Hessian matrix at QMLE
H <- numDeriv::hessian(func = function(params) sGARCH_loss_loglik(params, y, archOrder, garchOrder, per_obs = FALSE), x = theta_star_qmle)
# Numerical Score at QMLE
S <- numDeriv::jacobian(func = function(params) sGARCH_loss_loglik(params, y, archOrder, garchOrder, per_obs = TRUE), x = theta_star_qmle)
# Cross products of the score
B <- matrix(0, pq, pq)
for(i in 1:nrow(S)) {
B <- B + S[i,] %*% t(S[i,])
}
# Var-cov matrix (unbounded)
V_star <- solve(-H)
std.errors_zeta <- sqrt(diag(V_star))
names(std.errors_zeta) <- names(theta_star_qmle)
# Var-cov matrix (constraint)
V_orig <- J %*% V_star %*% t(J)
std.errors_phi <- sqrt(diag(V_orig))
names(std.errors_phi) <- names(theta_qmle)
# Sandwitch var-cov matrix (unbounded)
V_rob_star <- V_star %*% B %*% V_star
std.errors_rob_zeta <- sqrt(diag(V_rob_star))
names(std.errors_rob_zeta) <- names(theta_star_qmle)
# Sandwitch var-cov matrix (constraint)
V_rob_orig <- J %*% V_rob_star %*% t(J)
std.errors_rob_phi <- sqrt(diag(V_rob_orig))
names(std.errors_rob_phi) <- names(theta_qmle)
theta_qmle
theta_star_qmle
std.errors_zeta
std.errors_phi
std.errors_rob_zeta
std.errors_rob_phi
theta_qmle
}
#' # Simple GARCH(1,1)
#' set.seed(1)
#' x <- rnorm(1000)
#' omega <- 0.1; alpha <- 0.05; beta <- 0.9
#' s2 <- sGARCH_filter_c(x, omega, alpha, beta)  # no initials
#'
#' # With initials (k=max(p,q)=1)
#' s2_i <- sGARCH_filter_c(x, omega, alpha, beta, eps0 = 0, sigma20 = 0.2)
#'
#' @export
sGARCH_filter_c <- function(x, omega, alpha, beta, eps0 = NULL, sigma20 = NULL) {
if (is.null(eps0) != is.null(sigma20))
stop("Either provide both eps0 and sigma20, or neither.")
.Call("sGARCH_filter_c",
as.numeric(x),
as.numeric(omega),
as.numeric(alpha),
as.numeric(beta),
if (is.null(eps0)) NULL else as.numeric(eps0),
if (is.null(sigma20)) NULL else as.numeric(sigma20))
}
format(sGARCH_fit(x, 1, 2), digits = 4, scientific = FALSE)
spec <- rugarch::ugarchspec(variance.model = list(garchOrder = c(1, 2), variance.targeting = 1),
mean.model = list(armaOrder = c(0, 0), include.mean = FALSE))
# Safe GARCH fit
coef <- rugarch::ugarchfit(spec, x)@fit$coef
format(coef, digits = 4, scientific = FALSE)
sum(rugarch::ugarchfit(spec, x)@fit$log.likelihood)
system.time(purrr::map(1:100, ~rugarch::ugarchfit(spec, x)@fit$coef))
system.time(purrr::map(1:10, ~rugarch::ugarchfit(spec, x)@fit$coef))
system.time(purrr::map(1:10, ~format(sGARCH_fit(x, 1, 2), digits = 4, scientific = FALSE)))
spec <- rugarch::ugarchspec(variance.model = list(garchOrder = c(1, 1), variance.targeting = 1),
mean.model = list(armaOrder = c(0, 0), include.mean = FALSE))
# Safe GARCH fit
coef <- rugarch::ugarchfit(spec, x)@fit$coef
system.time(purrr::map(1:20, ~rugarch::ugarchfit(spec, x)@fit$coef))
system.time(purrr::map(1:20, ~format(sGARCH_fit(x, 1, 1), digits = 4, scientific = FALSE)))
rugarch::ugarchfit(spec, x)@fit$coef
sGARCH_fit(x, 1, 1), digits = 4, scientific = FALSE)
sGARCH_fit(x, 1, 1)
sGARCH_fit(x, 2, 1)
sGARCH_fit(x, 2, 2)
spec <- rugarch::ugarchspec(variance.model = list(garchOrder = c(2, 2), variance.targeting = 1),
mean.model = list(armaOrder = c(0, 0), include.mean = FALSE))
# Safe GARCH fit
coef <- rugarch::ugarchfit(spec, x)@fit$coef
system.time(purrr::map(1:20, ~rugarch::ugarchfit(spec, x)@fit$coef))
system.time(purrr::map(1:20, ~format(sGARCH_fit(x, 2, 2), digits = 4, scientific = FALSE)))
GARCH_filter
sGARCH_loss_loglik
coefficients
params
GARCH_params_to_phi(params)
GARCH_params_to_phi(params, 1, 1)
GARCH_params_to_phi(params, 1, 1)
GARCH_params_to_phi(c(params,0), 1, 1)
coefficients <- GARCH_params_to_phi(c(params,0), 1, 1)
coefficients
str_detect(names(coefficients), "alpha")
stringr::str_detect(names(coefficients), "alpha")
# ARCH
alpha <- coefficients[stringr::str_detect(params_names, "alpha")]
# GARCH
beta <- coefficients[stringr::str_detect(params_names, "beta")]
# Parameters names
params_names <- names(coefficients)
# Extract the parameters
omega <- coefficients["omega"]
# ARCH
alpha <- coefficients[stringr::str_detect(params_names, "alpha")]
# GARCH
beta <- coefficients[stringr::str_detect(params_names, "beta")]
alpha
sGARCH_loss_loglik
GARCH_filter
sGARCH_filter_c
# Simple GARCH(1,1)
set.seed(1)
x <- rnorm(1000)
sGARCH_filter_c(x, omega, alpha, beta)  # no initials
# With initials (k=max(p,q)=1)
sGARCH_filter_c(x, omega, alpha, beta, eps0 = 0, sigma20 = 0.2)
#' # Simple GARCH(1,1)
#' set.seed(1)
#' x <- rnorm(1000)
#' omega <- 0.1; alpha <- 0.05; beta <- 0.9
#' sGARCH_filter_c(x, omega, alpha, beta)  # no initials
#'
#' # With initials (k=max(p,q)=1)
#' sGARCH_filter_c(x, omega, alpha, beta, eps0 = 0, sigma20 = 0.2)
#'
#' @export
sGARCH_filter <- function(x, omega, alpha, beta, eps0 = NULL, sigma20 = NULL) {
if (is.null(eps0) != is.null(sigma20))
stop("Either provide both eps0 and sigma20, or neither.")
.Call("sGARCH_filter_c",
as.numeric(x),
as.numeric(omega),
as.numeric(alpha),
as.numeric(beta),
if (is.null(eps0)) NULL else as.numeric(eps0),
if (is.null(sigma20)) NULL else as.numeric(sigma20))
}
sGARCH_filter(x, omega, alpha, beta)  # no initials
# With initials (k=max(p,q)=1)
sGARCH_filter(x, omega, alpha, beta, eps0 = 0, sigma20 = 0.2)
